from inspect import getmembers, isfunction
from typing import Iterable, Literal, Union

from fastapi import FastAPI
from pydantic import BaseModel
from starlette.routing import Mount


class Endpoint(BaseModel):
    method: Literal["GET", "POST", "PUT", "DELETE", "PATCH"]
    path: str

    def __hash__(self):
        return hash((self.method, self.path))

    def __str__(self):
        method_str = f"Method: {self.method}".ljust(16)
        path_str = f"Path: {self.path}"
        return method_str + path_str


def gen_routes(app: Union[FastAPI, Mount]):
    """Yields and iterator of all endpoints of a FastAPI app (endpoint being HTTP method + path).

    Finds all endpoints (i.e. HTTP methods and paths) of an api, including endpoints
    from sub-mounted apps and routers. It is also careful to filter out the documentation
    endpoints auto-generated by FastAPI (the /docs, /redoc, etc).
    """
    for route_or_mount in app.routes:
        # route_or_mount represents a mounted sub-app
        if isinstance(route_or_mount, Mount):
            yield from (
                Endpoint(path=f"{route_or_mount.path}{endpt.path}", method=endpt.method)
                for endpt in gen_routes(route_or_mount)
            )
        # route_or_mount represents an actually endpoint
        else:
            path = route_or_mount.path
            if any([path.endswith(s) for s in ["docs", "redoc", "redirect", "json"]]):
                continue
            yield Endpoint(
                path=path,
                method=list(route_or_mount.methods)[0],
            )


def test_api_coverage():
    """Checks that there is an api_test for each endpoint in our main FastAPI app.

    The api tests are located in the api/api_tests directory and send test HTTP
    requests to our api endpoints to ensure we get the expected response.
    There should be at least one such api test for each endpoint, and this test
    function ensures that is the case. In order for this test coverage to match
    an api test with the corresponding endpoint, the api test is required to
    have a docstring whose first line is in the format: 'METHOD path', e.g.
    'GET /companies/{company_id}'.  This path should match exactly with
    the path used to register the endpoint with FastAPI.
    """
    import api_tests
    from main import app

    # Get all functions within the api_tests directory
    # NOTE: If paths are missing, make sure to update the api_tests api_tests/__init__.py file.
    api_tests_functions = getmembers(api_tests, isfunction)
    method_and_path = lambda docstring: {
        "method": docstring.split()[0],
        "path": docstring.split()[1],
    }

    tested_endpoints = {
        Endpoint(**method_and_path(f.__doc__))
        for (name, f) in api_tests_functions
        if "test" in name
    }

    # Get all endpoints in our api
    all_endpoints = set(gen_routes(app))

    # Check that each endpoints is contained in the set of tested_endpoints
    untested_endpoints = all_endpoints.difference(tested_endpoints)
    print_endpnts(
        untested_endpoints,
        "UNTESTED API ENDPOINTS",
        total_endpt_count=len(all_endpoints),
    )
    assert len(untested_endpoints) == 0


def test_gen_routes():
    """Test to check if the gen_routes function works correctly returns endpoints in a FastAPI with a sub-mounted app."""
    from fastapi import FastAPI

    app = FastAPI()

    @app.get("/top")
    def read_main():
        return {"message": "Hello World from main app"}

    sub_app = FastAPI()

    @sub_app.post("/sub")
    def read_sub():
        return {"message": "Hello World from sub-mounted API"}

    app.mount("/subapi", sub_app)

    expected_endpoints = {
        Endpoint(method="GET", path="/top"),
        Endpoint(method="POST", path="/subapi/sub"),
    }
    assert set(gen_routes(app)) == expected_endpoints


def print_endpnts(endpoints: Iterable[Endpoint], title: str, total_endpt_count: int):
    """Helper that prints each enpoint on a new line when test_coverage fails."""
    endpoints = sorted(endpoints, key=lambda endpt: len(endpt.path))
    centered_title = f"  {len(endpoints)}/{total_endpt_count} {title}  ".center(82, "=")
    equals_84 = "=" * 82
    print(equals_84)
    print(equals_84)
    print(centered_title)
    print()
    for endpt in endpoints:
        print(f"    - {endpt}")
    print()
    print(equals_84)
